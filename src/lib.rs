// wasm-pack uses wasm-bindgen to provide a bridge between the types of JavaScript and Rust
use wasm_bindgen::prelude::*;
use std::env;
use std::fs::File;
use std::io::{Write, Result};
use std::path::PathBuf;
use std::collections::HashMap;

// use ffi::ToCppString;
extern crate tobj;
extern crate tri_mesh;

use tri_mesh::Mesh;

// fn print_type_of<T>(_: &T) {
//     println!("{}", std::any::type_name::<T>())
// }

#[wasm_bindgen]
pub fn read_mesh_from_file() {
    println!("Reading mesh from file...");
    let mesh_cartography_lib_dir_str = env::var("Meshes_Dir").expect("MeshCartographyLib_DIR not set");
    let mesh_cartography_lib_dir = PathBuf::from(mesh_cartography_lib_dir_str);
    let new_path = mesh_cartography_lib_dir.join("ellipsoid_x4_open.obj");

    // Load the mesh from a file
    let model: three_d_asset::Model = three_d_asset::io::load_and_deserialize(new_path.clone()).expect("Failed loading asset");
    let surface_mesh = Mesh::new(&model.geometries[0]);

    // Test if the mesh is valid
    // println!("{:?}", surface_mesh.is_valid());
    println!("Mesh is closed: {:?}", surface_mesh.is_closed());

    // Test if the mesh was created correctly
    // assert_eq!(surface_mesh.no_vertices(), 4725);
    // assert_eq!(surface_mesh.no_faces(), 9336);

    // Save the mesh to a file
    let save_path = mesh_cartography_lib_dir.join("ellipsoid_x4_edited.obj");
    save_mesh_as_obj(&surface_mesh, save_path.clone()).expect("Failed to save mesh to file");

    // Find the boundary vertices
    let boundary_vertices = find_boundary_vertices(&surface_mesh);
    // print the size
    println!("Boundary vertices: {:?}", boundary_vertices.len());
}


fn save_mesh_as_obj(mesh: &tri_mesh::Mesh, file_path: PathBuf) -> Result<()> {
    let mut file = File::create(file_path)?;

    // Add meta data
    writeln!(file, "# Generated by MeshCartographyLib")?;

    // Write vertices
    for vertex_id in mesh.vertex_iter() {
        let vertex = mesh.vertex_position(vertex_id);
        writeln!(file, "v {} {} {}", vertex.x, vertex.y, vertex.z)?;
    }

    // Write faces
    for face_id in mesh.face_iter() {
        let face = mesh.face_vertices(face_id);

        // OBJ indices start at 1, so we need to add 1 to each index
        let f0 = face.0.to_string().parse::<i32>().unwrap() + 1;
        let f1 = face.1.to_string().parse::<i32>().unwrap() + 1;
        let f2 = face.2.to_string().parse::<i32>().unwrap() + 1;

        writeln!(file, "f {} {} {}", f0, f1, f2)?;
    }

    Ok(())
}


pub fn find_boundary_vertices(surface_mesh: &Mesh) -> Vec<tri_mesh::VertexID> {
    let mut boundary_edges = Vec::new(); // A vector to store boundary edges

    for edge in surface_mesh.edge_iter() {
        // Returns the vertex id of the two adjacent vertices to the given edge.
        let v0 = surface_mesh.edge_vertices(edge).0;
        let v1 = surface_mesh.edge_vertices(edge).1;

        if surface_mesh.is_vertex_on_boundary(v0) && surface_mesh.is_vertex_on_boundary(v1) {
            boundary_edges.push((v0, v1));
        }
    }

    // Create a map for easy look-up
    let mut edge_map = HashMap::new();
    for &(v0, v1) in &boundary_edges {
        edge_map.insert(v0, v1);
    }

    // Get the first key from the HashMap
    let start_key = *edge_map.keys().next().expect("HashMap is empty");

    let mut current_key = start_key;
    let mut boundary_vertices = Vec::new();

    // Iterate through the HashMap
    while let Some(&next_value) = edge_map.get(&current_key) {
        boundary_vertices.push(next_value);
        current_key = next_value;

        // Optional: Break condition if the sequence becomes too long or cyclic
        if boundary_vertices.len() > edge_map.len() {
            break;
        }
    }

    // ? Pop the last element from the vector
    boundary_vertices.pop();

    boundary_vertices
}


#[wasm_bindgen]
extern {
    pub fn alert(s: &str);
}

#[wasm_bindgen]
pub fn greet() {
    alert("Hello, py-torch!");
}
